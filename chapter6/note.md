#### CUDA内存处理

存储带宽：一定时间内从DRAM读出或者写入的数据量。延迟：响应一个获取内存的请求所花费的时间。

高速缓存的最大速度与缓存的大小成反比。缓存在处理器的核或者SM之间进行共享。

**数据储存类型**

GPU提供了不同层次的若干区域来存放数据，每块区域根据其能够达到的最大带宽以及延迟而定义。比如有独立的一级缓存和共享的二级缓存。最快速的依次为寄存器，共享内存，常量内存，纹理内存，常规设备内存，最后是主机端内存。我们要思考如何高效地访问全局内存，也要想办法减少对全局内存的访问次数。

#### 寄存器的用法

GPU的每个SM有上千个寄存器。CPU和GPU架构的一个主要区别就是他们中的映射寄存器的方式。CPU在运行新的任务的时候需要进行上下文切换。而GPU利用多线程来隐藏一些内存获取与指令执行带来的延迟。所以在GPU上进行上下文切换的时候，所需要的操作就是将指向当前寄存器的指针进行更新。

GPU能够在硬件上调度的线程块分配固定数目的寄存器组。每个SM使用的寄存器的空间大小也不同。**指令级的并行**是可以用流水线的技术来实现的。

如何使用寄存器来进行优化牵涉到编译器。

使用全局内存的内核函数中，线程块中的每个线程都在进行读写。但是没有保证按照怎么样的顺序运行。因此输出是不确定的。使用寄存器能够带来很大的优化效果。

#### 共享内存

共享内存是用户可以控制的一级缓存。当数据重复利用，全局内存合并，或者线程之间有共享数据时使用共享内存才更加合适。共享内存是基于存储体切换的架构。所以我们必须要解决存储体冲突的问题。线程访问共享内存的时候需要排队等候。

**共享内存排序**

在GPU上线程块的大小或者线程束的大小可以理想地映射为数据集的大小。对于一个长为N的数据，我们可以最多用N/2个线程来进行。

以行的方式访问全局内存的时候，性能最好。

#### 并行归约

他可以使用数据集元素数量一半的线程，每个线程将当前线程对于的元素与另外一个元素进行比较，计算两者之间的最小值，这样就可以将最小值移到最前面。每进行一次比较，线程数目就减少一半，这样可以直到只剩下一个元素为止。